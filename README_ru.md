# Набор программ для изменения wav-файлов на Си

![LOGO](https://github.com/ferrovovan/C-wave-change-pack/blob/main/Logo.png)  

Использование данного программного обеспечения предполагает **от пользователя**  знания:  
1. Что такое директория.
2. Как открыть терминал в нужной директории.
3. Как использовать исполняемый файл в терминале.
4. Применение следующей аналогии:  
  Если программа `./build/cut_wav` выводит справку  
"""  
  Параметры:  
   [ -i | --input ] <входной_файл>   
   [ -s | --start ] <начало>  
   [ -e | --end ]   <конец>  
   [ -o | --output ] <выходной_файл>  
   --test   вывод статистики предполагаемого результата  
"""  
  То использовать её нужно шаблоном `./build/cut_wav -i <входной_файл> -s <начало обрезки> -e <конец обрезки> -o <выходной_файл>`.  
  
  
Набор кода для чтения и изменения wav файлов.  
Программы для чтения и изменения wav-файлов.  
Обрабатывают только PCM-совместимые форматы (
смотри ![WAVE Specifications/rfc2361.txt](https://github.com/ferrovovan/C-wave-change-pack/blob/update_readme/WAVE%20Specifications/rfc2361.txt)  300 строку, 
или ![WAVE Specifications/Wave File Specifications.html](https://github.com/ferrovovan/C-wave-change-pack/blob/update_readme/WAVE%20Specifications/Wave%20File%20Specifications.html)
).  
  
Доступные программы:
- `wav_info`
- `concat_wav`
- `mult_wav`
- `cut_wav`
- `two_channels_wav`
- `form_pitch`
- `zero_wav (null_wav)`
- `1_hour_wav`
- `fan_1_hour_wav`

#### Описание программ
- wav_info  
Выводит информацию об wav-файле.

- concat_wav  
Конкатенирует 2 схожих по формату wav-файла.

- mult_wav  
Конкатенирует wav-файл с самим собой.

- cut_wav  
Вырезает промежуток заданной длины.

- two_channels_wav  
Конвертирует моно стерео.  

- form_pitch  
Записывает звуковую волну нужной частоты и амплитуды

- zero_wav (null_wav)  
Создаёт пустой wav-файл заданной длительностью.

- 1_hour_wav  
Растягивает аудио до заданной длительности, путём копирования выбранного фрагмента.  

- fan_1_hour_wav  
Тоже что и 1_hour_wav, но с неправильной расшифровкой байтов, приводящей к странным результатам.



### Сборка (компиляция)
Перейдите в **корневую** директорию и используйте команду шаблоном `make <program_name>`, где *<program_name>* - название программы из списка *Доступные программы*. Компилирует программу в директорию **build**.   
Пример команды:
```
make cut_wav
```
Это создаст исполняемый файл *cut_wav* в директории **build** (*cut_wav.exe* в Windows).  
  
Или скомпилируйте все программы разом!
```
make all
```

### Как использовать?
1. Скомпилируйте выбранную программу.
2. Переместите её в свою рабочую директорию (где лежат 'рабочие'-wave-файлы).
3. Откройте там терминал (консоль).
4. Напишите команду по шаблону:  
Для Windows: `<program_name>.exe [параметры]`  
Для Linux: `./<program_name> [параметры]`  
  
Если параметры не заданы, выводится справка по использованию.  
Все примеры указаны для Linux (отличаются `./`).
  
Параметры программ:
##### wav_info  
<входной_файл> - путь до входного файла.  
Пример:  
```
./build/wav_info samples/Sidorovich.wav
```
Печатает информацию из заголовка *Sidorovich.wav*  
  
##### concat_wav  
 <входной_файл1> <входной_файл2> <выходной_файл> - пути до файлов.  
 <входной_файл1> и <входной_файл2> должны быть различны! Для повторения файла используйте mult_wav.  
Пример:  
```
./build/concat_wav "samples/phrase 1.wav" "samples/phrase 2.wav" "concated phrase.wav"
```
Сконкатенирует wav-файлы *phrase 1.wav* и *phrase 2.wav* **одинакового формата** в *concated phrase.wav* .  
  
##### mult_wav
-i <входной_файл> - путь до входного файла.  
-o <выходной_файл> - путь до выходного файла.  
-c <повторения> - количество вхождений *входного* в *исходящий* файл ( >1 ).  
Пример:  
```
./mult_wav -i samples/Sidorovich.wav --count 3 --output "Wash now.wav"
```
В *Wash now.wav* будет 3 последовательных *Sidorovich.wav* .
  
  
##### cut_wav  
-i  <входной_файл> -o <выходной_файл> -s <начало обрезки> -e <конец обрезки>  
Метки записывается в `HH:MM:SS.MS` формате.  
Пример:  
```
./build/cut_wav -i "samples/Tchaikovsky - Piano Concerto 1 (B Flat Minor).wav" -s 2:20 -e 3:5.2 -o "sonata-allegro.wav"
```
Вырезает фрагмент из *Tchaikovsky - Piano Concerto 1 (B Flat Minor).wav* [^1] в *sonata-allegro.wav*, начиная со второй минуты 20 секунды , заканчивая третьей минутой 5 секундой 2 десятыми секунды.  

[^1]: Нужно преобразовать в wav:   
`ffmpeg -i "samples/Tchaikovsky - Piano Concerto 1 (B Flat Minor).ogg" "samples/Tchaikovsky - Piano Concerto 1 (B Flat Minor).wav"`

##### two_channels_wav  
-i <входной_файл> -o <выходной_файл>  
Пример:  
```
./build/two_channels_wav --input samples/Sidorovich.wav -o stereo.wav
```
*stereo.wav* - стерео звук, в отличие от *Sidorovich.wav* с моно.  
  
##### zero_wav (null_wav)  
-o <выходной_файл> -d <длительность>   
длительность записывается в `HH:MM:SS.MS` формате.  
Пример:  
```
./build/zero_wav -o null.wav -d 6:5.43
```
Создаёт файл пустой wav-файл *null.wav*, длительностью 6 минут 5 секунд + 43 сотых секунды.  
  
##### form_pitch  
<название выходного файла> <Частота> <амплитуда (громкость)> <длительность в секундах>  
Пример:  
```
./build/form_pitch_wav A.wav 440.00 0.5 1
```
Создаёт волну частотой 440 Герц (Нота Ля) длительностью 1 секунда, громкостью 0,5 (какая-то громкость).  

##### 1_hour_wav
-i <входной_файл> -st <начало повтора> -end <конец повтора> -md <длительность наложения> -ed <ожидаемая длительность> -o <выходной_файл>  
Добавление --test выводит параметры предполагаемого выходного файла.  

Пример:  
```
./build/1_hour_extender -i "samples/The Amazing Digital Circus - Main Theme.wav" -st 35.5 -end 48.3  -ed 3:28  -o "day after day after day.wav" -md 0.3
```
Начало до 34,5 секунды   
 \+ дублируется промежуток с 34,5 до 01:33,2  два раза (смотрите --test)   
 \+ конец с 01:33,2 до 01:52,34   
= итого 3 минуты 45 секунд.
